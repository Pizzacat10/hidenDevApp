-- NPC AI Script by finn maymon
-- Simple NPC AI with pathfinding, attacking, wandering, and tree destruction behavior

local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local Workspace = game:GetService("Workspace")

local npc = workspace:FindFirstChild("the mimic")
local humanoid = npc:WaitForChild("Humanoid")
local humanoidRootPart = npc:WaitForChild("HumanoidRootPart")

local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)

-- Load animations for walk, attack, and special action
local walkAnim = Instance.new("Animation")
walkAnim.AnimationId = "rbxassetid://130563157348265"
local walkAnimation = animator:LoadAnimation(walkAnim)

local attackAnim = Instance.new("Animation")
attackAnim.AnimationId = "rbxassetid://133138715796123"
local attackAnimation = animator:LoadAnimation(attackAnim)

local specialAnim = Instance.new("Animation")
specialAnim.AnimationId = "rbxassetid://117110635321254"
local specialAnimation = animator:LoadAnimation(specialAnim)

local lastAttackTime = 0
local attackCooldown = 2
local actionCounter = 0

-- Finds the closest player to the NPC for interaction or attack
local function getClosestPlayer()
	local closestPlayer = nil
	local shortestDistance = math.huge

	for _, player in pairs(Players:GetPlayers()) do
		local character = player.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			local distance = (humanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude
			if distance < shortestDistance then
				closestPlayer = player
				shortestDistance = distance
			end
		end
	end

	return closestPlayer
end

-- Rotates NPC to face a target position horizontally
local function facePosition(position)
	local currentPos = humanoidRootPart.Position
	local lookAt = CFrame.new(currentPos, Vector3.new(position.X, currentPos.Y, position.Z))
	humanoidRootPart.CFrame = lookAt
end

-- Uses Roblox pathfinding to move NPC to a destination, waiting until movement finishes or fails
local function moveToPosition(destination)
	local path = PathfindingService:CreatePath({
		AgentRadius = 2,
		AgentHeight = 6,
		AgentCanClimb = true,
		AgentCanJump = true,
	})

	print("Computing path to", destination)
	path:ComputeAsync(humanoidRootPart.Position, destination)

	if path.Status ~= Enum.PathStatus.Success then
		print("Path computation failed with status:", path.Status.Name)
		return false
	end

	local waypoints = path:GetWaypoints()
	print("Path computed successfully with", #waypoints, "waypoints")

	walkAnimation:Play()

	for i, waypoint in ipairs(waypoints) do
		print("Moving to waypoint", i, waypoint.Position)
		humanoid:MoveTo(waypoint.Position)
		local reached = humanoid.MoveToFinished:Wait()
		print("Reached waypoint", i, "result:", reached)

		if not reached then
			print("Failed to reach waypoint", i)
			walkAnimation:Stop()
			return false
		end
	end

	walkAnimation:Stop()
	return true
end

-- Applies a physics impulse to push the player backward when attacked
local function pushPlayerBack(player)
	local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local direction = (hrp.Position - humanoidRootPart.Position).Unit
		local impulse = direction * 250
		if hrp:IsA("BasePart") then
			hrp:ApplyImpulse(impulse)
		end
	end
end

-- Attacks a player if cooldown allows, plays attack animation and damages player
local function attackPlayer(player)
	if tick() - lastAttackTime < attackCooldown then
		return
	end
	lastAttackTime = tick()

	if not attackAnimation.IsPlaying then
		attackAnimation:Play()
	end

	local targetHumanoid = player.Character and player.Character:FindFirstChild("Humanoid")
	if targetHumanoid then
		targetHumanoid:TakeDamage(25)
		pushPlayerBack(player)
	end
end

-- Moves NPC randomly within a radius to simulate wandering
local function wanderRandomly()
	local wanderRadius = 20
	local randomAngle = math.random() * 2 * math.pi
	local offset = CFrame.Angles(0, randomAngle, 0).LookVector * wanderRadius

	moveToPosition(humanoidRootPart.Position + offset)
end

-- Finds the closest tree tagged with "Tree" for the NPC to interact with
local function getClosestTree()
	local closestTree = nil
	local shortestDistance = math.huge

	for _, tree in ipairs(CollectionService:GetTagged("Tree")) do
		if tree:IsA("BasePart") then
			local distance = (humanoidRootPart.Position - tree.Position).Magnitude
			if distance < shortestDistance then
				closestTree = tree
				shortestDistance = distance
			end
		end
	end

	return closestTree
end

-- Moves NPC to the closest tree and destroys it, applying impulse if not anchored
local function destroyClosestTree()
	local tree = getClosestTree()
	
	print(tree)
	
	if not tree then return end

	-- Ensure target Y coordinate matches NPC's Y for successful pathfinding
	local targetPos = Vector3.new(tree.Position.X, humanoidRootPart.Position.Y, tree.Position.Z)
	
	local reached = moveToPosition(targetPos)
	if not reached then return end

	facePosition(tree.Position)
	task.wait(1)

	if tree and tree.Parent then
		if not tree.Anchored then
			tree:ApplyImpulse(Vector3.new(0, 400, 0))
		end
		tree:Destroy()
	end
end

-- Walks near the closest player, offset by a random radius and angle
local function walkNearPlayer()
	local player = getClosestPlayer()
	if not player then return end

	local playerPos = player.Character.HumanoidRootPart.Position
	local angle = math.random() * 2 * math.pi
	local radius = 15 + math.random() * 10

	local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
	moveToPosition(playerPos + offset)
end

-- Chases the closest player and attacks if in range
local function chasePlayer()
	local player = getClosestPlayer()
	if not player then return end

	task.spawn(function()
		while player and player.Parent do
			local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then break end

			local distance = (humanoidRootPart.Position - hrp.Position).Magnitude
			if distance > 6 then
				humanoid:MoveTo(hrp.Position)
			else
				facePosition(hrp.Position)
				attackPlayer(player)
				break
			end

			task.wait(0.25)
		end
	end)
end

-- Main AI loop deciding NPC behavior based on action count
local function behaviorLoop()
	while true do
		-- After several actions, do a special chase behavior
		if actionCounter >= math.random(5, 10) then
			specialAnimation:Play()
			task.wait(2)
			chasePlayer()
			specialAnimation:Stop()
			actionCounter = 0
		else
			-- Choose a behavior: 1 = wander, 2 = destroy tree, 3 = walk near player
			local choice = 2
			if choice == 1 then
				wanderRandomly()
			elseif choice == 2 then
				destroyClosestTree()
			elseif choice == 3 then
				walkNearPlayer()
			end
			actionCounter = actionCounter + 1
		end

		task.wait(math.random(1, 2)) -- Wait a bit before next action to avoid spamming
	end
end

-- Start the NPC behavior loop
behaviorLoop()
