-- Simple, easy to understand script with pathfinding, attacking, wandering, and tree destruction

local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local Workspace = game:GetService("Workspace")

-- References to the NPC model and components
local npc = workspace:FindFirstChild("the mimic")
local humanoid = npc:WaitForChild("Humanoid")
local humanoidRootPart = npc:WaitForChild("HumanoidRootPart")

-- Setup animator and animations (walking, attacking, special)
local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
local walkAnim = Instance.new("Animation")
walkAnim.AnimationId = "rbxassetid://130563157348265"
local walkAnimation = animator:LoadAnimation(walkAnim)

local attackAnim = Instance.new("Animation")
attackAnim.AnimationId = "rbxassetid://133138715796123"
local attackAnimation = animator:LoadAnimation(attackAnim)

local specialAnim = Instance.new("Animation")
specialAnim.AnimationId = "rbxassetid://117110635321254"
local specialAnimation = animator:LoadAnimation(specialAnim)

local lastAttackTime = 0
local attackCooldown = 2
local actionCounter = 0

-- Finds the nearest player for NPC to interact with
local function getClosestPlayer()
	local closestPlayer = nil
	local shortestDistance = math.huge

	for _, player in pairs(Players:GetPlayers()) do
		local character = player.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			local distance = (humanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude
			if distance < shortestDistance then
				closestPlayer = player
				shortestDistance = distance
			end
		end
	end

	return closestPlayer
end

-- Rotates NPC to face a specific position horizontally
local function facePosition(position)
	local currentPos = humanoidRootPart.Position
	local lookAt = CFrame.new(currentPos, Vector3.new(position.X, currentPos.Y, position.Z))
	humanoidRootPart.CFrame = lookAt
end

-- Uses Roblox PathfindingService to move NPC smoothly to a target destination
-- Plays walking animation during movement and waits for each waypoint to be reached
local function moveToPosition(destination)
	local path = PathfindingService:CreatePath({
		AgentRadius = 2,
		AgentHeight = 6,
		AgentCanClimb = true,
		AgentCanJump = true,
	})

	print("Computing path to", destination)
	path:ComputeAsync(humanoidRootPart.Position, destination)

	if path.Status ~= Enum.PathStatus.Success then
		print("Path computation failed with status:", path.Status.Name)
		return false
	end

	local waypoints = path:GetWaypoints()
	print("Path computed successfully with", #waypoints, "waypoints")

	walkAnimation:Play()

	for i, waypoint in ipairs(waypoints) do
		print("Moving to waypoint", i, waypoint.Position)
		humanoid:MoveTo(waypoint.Position)
		local reached = humanoid.MoveToFinished:Wait()
		print("Reached waypoint", i, "result:", reached)

		if not reached then
			print("Failed to reach waypoint", i)
			walkAnimation:Stop()
			return false
		end
	end

	walkAnimation:Stop()
	return true
end

-- Applies a physical push to player when attacked, adding impact feel to combat
local function pushPlayerBack(player)
	local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local direction = (hrp.Position - humanoidRootPart.Position).Unit
		local impulse = direction * 250
		if hrp:IsA("BasePart") then
			hrp:ApplyImpulse(impulse)
		end
	end
end

-- Performs an attack if cooldown allows, deals damage, and pushes the player back
local function attackPlayer(player)
	if tick() - lastAttackTime < attackCooldown then
		return
	end
	lastAttackTime = tick()

	if not attackAnimation.IsPlaying then
		attackAnimation:Play()
	end

	local targetHumanoid = player.Character and player.Character:FindFirstChild("Humanoid")
	if targetHumanoid then
		targetHumanoid:TakeDamage(25)
		pushPlayerBack(player)
	end
end

-- Causes the NPC to wander randomly around its current position to simulate natural movement
local function wanderRandomly()
	local wanderRadius = 20
	local randomAngle = math.random() * 2 * math.pi
	local offset = CFrame.Angles(0, randomAngle, 0).LookVector * wanderRadius

	moveToPosition(humanoidRootPart.Position + offset)
end

-- Finds the closest tree tagged with "Tree" for the NPC to interact with (destroy)
local function getClosestTree()
	local closestTree = nil
	local shortestDistance = math.huge

	for _, tree in ipairs(CollectionService:GetTagged("Tree")) do
		if tree:IsA("BasePart") then
			local distance = (humanoidRootPart.Position - tree.Position).Magnitude
			if distance < shortestDistance then
				closestTree = tree
				shortestDistance = distance
			end
		end
	end

	return closestTree
end

-- Moves to the closest tree and destroys it after facing it
-- Adds a delay to simulate interaction time
local function destroyClosestTree()
	local tree = getClosestTree()

	print(tree)

	if not tree then return end

	local targetPos = tree.Position
	targetPos = Vector3.new(targetPos.X, humanoidRootPart.Position.Y, targetPos.Z)
	moveToPosition(targetPos)

	if not targetPos then return end

	facePosition(tree.Position)
	task.wait(1)

	if tree and tree.Parent then
		if not tree.Anchored then
			tree:ApplyImpulse(Vector3.new(0, 400, 0))
		end
		tree:Destroy()
	end
end


-- Moves the NPC near a player, simulating stalking or patrolling behavior
local function walkNearPlayer()
	local player = getClosestPlayer()
	if not player then return end

	local playerPos = player.Character.HumanoidRootPart.Position
	local angle = math.random() * 2 * math.pi
	local radius = 15 + math.random() * 10

	local offset = Vector3.new(math.cos(angle) * radius, 0, math.sin(angle) * radius)
	moveToPosition(playerPos + offset)
end

-- NPC chases the closest player and attacks if close enough
-- Runs in a separate task to allow asynchronous chasing behavior
local function chasePlayer()
	local player = getClosestPlayer()
	if not player then return end

	task.spawn(function()
		while player and player.Parent do
			local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then break end

			local distance = (humanoidRootPart.Position - hrp.Position).Magnitude
			if distance > 6 then
				humanoid:MoveTo(hrp.Position)
			else
				facePosition(hrp.Position)
				attackPlayer(player)
				break
			end

			task.wait(0.25)
		end
	end)
end

-- Main behavior loop controlling NPC actions
-- Performs a special action every 5-10 cycles, otherwise picks random behaviors
local function behaviorLoop()
	while true do
		if actionCounter >= math.random(5, 10) then
			specialAnimation:Play()
			task.wait(2)
			chasePlayer()
			specialAnimation:Stop()
			actionCounter = 0
		else
			local choice = math.random(1,3)
			if choice == 1 then
				wanderRandomly()
			elseif choice == 2 then
				destroyClosestTree()
			elseif choice == 3 then
				walkNearPlayer()
			end
			actionCounter = actionCounter + 1
		end

		task.wait(math.random(1, 2))
	end
end

-- Start the AI behavior loop
behaviorLoop()
